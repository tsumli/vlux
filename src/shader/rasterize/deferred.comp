#version 460

struct TransformParams {
    mat4x4 world;
    mat4x4 view_proj;
    mat4x4 world_view_proj;
    mat4x4 proj_to_world;
};

struct CameraParams {
    vec4 pos;
};

struct LightParams {
    vec4 pos;
    float range;
    vec4 color;
};

struct ModePushConstants {
    uint mode;
};

layout(push_constant) uniform push_mode { ModePushConstants mode; };

layout(set = 0, binding = 0) uniform ubo_transform { TransformParams transform; };

layout(set = 0, binding = 1) uniform ubo_camera { CameraParams camera; };

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, set = 1, binding = 0) uniform readonly image2D color;
layout(rgba32f, set = 1, binding = 1) uniform readonly image2D normal;
layout(rgba32f, set = 1, binding = 2) uniform readonly image2D position;
layout(rgba32f, set = 1, binding = 3) uniform readonly image2D emissive;
layout(r32f, set = 1, binding = 4) uniform image2D depth;
layout(rgba32f, set = 1, binding = 5) uniform writeonly image2D result;

layout(set = 2, binding = 0) uniform ubo_light { LightParams light; };

vec4 ReconstructWorldPositionFromDepth(in vec2 coords, in float depth, in float inv_width,
                                       in float inv_height) {
    const vec2 inv_screen_res = vec2(inv_width, inv_height);

    //! normalize from [0, 1] to [-1, 1] and flip vertically, then
    //! (-1, -1): bottom left, (1, 1): top right
    const vec2 screen_pos = (coords * inv_screen_res) * 2.0f - 1.0f;

    const vec4 raw_world_pos =
        transform.proj_to_world * vec4(screen_pos * vec2(1.0f, -1.0f), depth, 1.0f);
    return raw_world_pos / raw_world_pos.w;
}

vec4 CalcLighting(in const vec3 position, in const vec3 normal, in const float specular_power) {
    vec3 light_dir = light.pos.xyz - position;
    const float dist = length(light_dir);
    light_dir /= dist;
    const float attenuation = max(0, 1.0f - (dist / light.range));

    float n_dot_l = clamp(dot(normalize(normal), light_dir), 0.0, 1.0);
    vec3 diffuse = n_dot_l * light.color.xyz * attenuation;

    const vec3 view_dir = normalize(camera.pos.xyz - position);
    const vec3 half_dir = normalize(light_dir + view_dir);
    const float specular =
        pow(clamp(dot(normal, half_dir), 0.0, 1.0), specular_power) * attenuation * n_dot_l;
    return vec4(diffuse, specular);
}

void main() {
    const uint width = imageSize(result).x;
    const uint height = imageSize(result).y;
    if (gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height) {
        return;
    }

    const float pixel_depth = imageLoad(depth, ivec2(gl_GlobalInvocationID.xy)).x;
    const vec4 position = imageLoad(position, ivec2(gl_GlobalInvocationID.xy));

    const vec4 pixel_color = imageLoad(color, ivec2(gl_GlobalInvocationID.xy));
    const vec4 pixel_normal = imageLoad(normal, ivec2(gl_GlobalInvocationID.xy));
    const vec4 pixel_emissive = imageLoad(emissive, ivec2(gl_GlobalInvocationID.xy));

    const vec4 lighting = CalcLighting(position.xyz, pixel_normal.xyz, 2.0f);

    const vec3 pixel_specular = {1, 1, 1};
    const vec3 diffuse = lighting.xyz * pixel_color.xyz;
    const vec3 specular = lighting.w * pixel_specular.xyz;

    vec3 final_color = diffuse + specular + pixel_emissive.xyz;
    final_color = pow(final_color, vec3(0.45));  // gamma correction

    switch (mode.mode) {
        case 0:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(final_color.xyz, 1.0f));
            break;
        case 1:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_color.xyz, 1.0f));
            break;
        case 2:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_normal.xyz, 1.0f));
            break;
        case 3:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(position.xyz, 1.0f));
            break;
        case 4:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy),
                       vec4(pixel_depth, 0.0f, 0.0f, 1.0f));
            break;
        case 5:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(lighting.xyz, 1.0f));
            break;
        case 6:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(lighting.w, 0.0f, 0.0f, 1.0f));
            break;
        case 7:
            imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_emissive.xyz, 1.0f));
            break;
        default:
            break;
    }
}