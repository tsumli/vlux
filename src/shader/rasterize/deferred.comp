#version 460

struct TransformParams {
    mat4x4 world;
    mat4x4 view_proj;
    mat4x4 world_view_proj;
    mat4x4 proj_to_world;
};

struct LightParams {
    vec4 light_pos;
    vec4 light_color;
    vec4 light_direction;
    vec4 spotlight_angles;
    vec4 light_range;
};

layout(set = 0, binding = 0) uniform ubo {
    TransformParams transform;
};

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, set = 1, binding = 0) uniform readonly image2D color;
layout(rgba32f, set = 1, binding = 1) uniform readonly image2D normal;
layout(rgba32f, set = 1, binding = 2) uniform readonly image2D depth;
layout(rgba32f, set = 1, binding = 3) uniform writeonly image2D result;

vec4 RestoreWorldPositionFromDepth(
    in vec2 coords, in float depth, in float inv_width,
    in float inv_height, in mat4x4 proj_to_world)
{
    vec2 inv_screen_res = vec2(inv_width, inv_height);
    vec2 screen_pos =
        (coords * inv_screen_res) * vec2(2.0f, -2.0f) + vec2(-1.0f, 1.0f);
    vec4 raw_world_pos = transform.proj_to_world * vec4(screen_pos, depth, 1.0f);
    return raw_world_pos / raw_world_pos.w;
}

vec4 CalcLighting(in vec3 normal, in vec3 position, in float specular_power)
{
    vec3 light_pos = {78, 20, -12};
    vec3 light_range = {1000.0f, 10, 10};
    vec3 light_color = {1, 1, 1};
    vec3 camera_pos = {80, 20, -12};

    vec3 l = {0, 0, 0};
    float attenuation = 1.0f;
    l = light_pos.xyz - position;
    float dist = length(l);
    attenuation = max(0, 1.0f - (dist / light_range.x));
    l /= dist;

    float n_dot_l = clamp(dot(normal, l), 0.0, 1.0);
    vec3 diffuse = n_dot_l * light_color.xyz * attenuation;

    vec3 v = camera_pos.xyz - position;
    vec3 h = normalize(l + v);
    float specular = pow(clamp(dot(normal, h), 0.0, 1.0), specular_power) * attenuation * n_dot_l;
    return vec4(diffuse, specular);
}

void main() {
  uint width = imageSize(result).x;
  uint height = imageSize(result).y;
  if (gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height) {
    return;
  }

  // Restore position from depth
  vec4 position = RestoreWorldPositionFromDepth(
    vec2(gl_GlobalInvocationID.xy), imageLoad(depth, ivec2(gl_GlobalInvocationID.xy)).x,
    1.0 / width, 1.0 / height, transform.proj_to_world);

  vec4 pixel_color = imageLoad(color, ivec2(gl_GlobalInvocationID.xy));
  vec4 pixel_normal = imageLoad(normal, ivec2(gl_GlobalInvocationID.xy));

  vec4 lighting = CalcLighting(pixel_normal.xyz, position.xyz, 20.0f);

  vec3 pixel_specular = {1, 1, 1};
  vec3 diffuse = lighting.xyz * pixel_color.xyz;
  vec3 specular = lighting.w * pixel_specular.xyz;

  vec3 final_color = diffuse + specular;
  final_color = pow(final_color, vec3(0.45));  // gamma correction
  imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(final_color.xyz, 1.0f));
}